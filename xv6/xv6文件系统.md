### 文件系统概念

文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中。

### 文件系统的组成

Linux ⽂件系统会为每个⽂件分配两个**数据结构**：**索引节点**（index node）和**⽬录项**（directoryentry），它们主要⽤来记录⽂件的元信息和⽬录层次结构。

##### **索引节点**

也就是 inode，⽤来记录⽂件的元信息，⽐如**inode 编号、⽂件⼤⼩、访问权限、创建时间、修改时间、数据在磁盘**的位置等等。索引节点是⽂件的唯⼀标识，它们之间⼀⼀对应，也同样都会被存储在硬盘中，所以索引节点同样占⽤磁盘空间。

在xv6系统中，索引节点就是inode，它在磁盘中的保存格式是struct dinode ，在内存中的保存格式是struct inode。struct inode比struct dinode有更多的信息，比如是否从磁盘拷贝进来等。操作所有的block都是通过先在内存中操作block对应的cache，然后写入log层，在commit到data block（磁盘中专门存储数据的块，目录下的entry也是存储在这里）中这样的逻辑来实现的。内存中含有log header，buf，和inode的缓存。（struct log ; struct buf/ struct bcache; struct icache）. 在分配或者通过bread等函数去读这些inode,buf结构体时，都会先到缓存中看看是否已经读入，没有的话再从磁盘中读入，并添加到缓存中。

##### **⽬录项**

 也就是 dentry，⽤来记录⽂件的名字、索引节点指针以及与其他⽬录项的层级关联关系。多个⽬录项关联起来，就会形成⽬录结构，但它与索引节点不同的是，⽬录项是由内核维护的⼀个数据结构，不存放于磁盘，⽽是缓存在内存。

这里的目录项对应的是xv6中内存中的struct inode。

##### **⽬录项和⽬录是⼀个东⻄吗？**

通用文件系统中：虽然名字很相近，但是它们不是⼀个东⻄，⽬录是个⽂件，持久化存储在磁盘，⽽⽬录项是内核⼀个数据结构，缓存在内存。目录是存在磁盘中的数据结构，目录项是存在内存中的包含目录信息的数据结构。cpu首先从内存的目录缓存中操作文件，然后写入磁盘，cpu操作的是目录项。

##### **在xv6**中就是struct inode与struct dinode的区别。

**xv6中**，目录是与普通文件不同的inode类型，是inode，目录的inode中对应的block保存的是entry，而且保存在磁盘中。

### 文件的使用

通过系统调用操作文件。

打开了一个文件后，操作系统会跟踪进程打开的所有文件。操作系统为每个进程维护一个**打开文件表**，文件表里的每一项代表「**文件描述符**」。

文件指针：系统跟踪上次读写位置作为当前文件位置指针，xv6中是off

文件打开计数器；xv6中是ref

文件磁盘位置：在xv6中是blockno

访问权限：只读只写等

inode结构体：

在xv6中，文件打开表是**struct file *ofile[NOFILE];** 在进程结构体下能够找到，每个进程一个。xv6中的文件描述符就是数组索引。数组中的每一项就是struct file结构体。

### 文件存储（文件在磁盘中的存储方式）

#### 连续空间存放方式：**文件存放在磁盘「连续的」物理空间中**

**文件头里需要指定「起始块的位置」和「长度」，也就是inode中要包含这两个信息，通过这两个信息去磁盘中寻找文件**#### 

好处：文件的数据都是紧密相连，**读写效率很高**一次磁盘寻道就可以读出整个文件。

缺点：**有「磁盘空间碎片」（外部磁盘碎片）和「文件长度不易扩展」的缺陷。**

外部磁盘碎片：新来的文件想要存到磁盘中，那么需要找到一段足够的连续空间来存放文件，所以会出现空闲磁盘的空间足够放下文件，但是不连续，所以导致文件存不进去，以及一些空间永远也用不上，产生外部碎片。

文件长度不易扩展；文件可能紧密存放，所以扩大时需要将后面的文件向后挪，知道挪出足够扩展的空间。

### 非连续空间存放方式

非连续空间存放方式分为 **「链表方式」和「索引方式」**。

##### **链表方式** ： **隐式链表**和**显式链接**

好处：链表的方式存放是**离散的，不用连续的**，于是就可以**消除磁盘碎片**，**文件的长度可以动态扩展。

**隐式链表**：实现的⽅式是⽂件头（inode）要包含「第⼀块」和「最后⼀块」的位置，并且每个数据块⾥⾯留出⼀个指针空间，⽤来存放下⼀个数据块的位置。

缺点：

1. ⽆法直接访问数据块，只能通过指针顺序访问⽂件，以及数据块指针消耗
   了⼀定的存储空间。

2. 稳定性差，链表中的指针丢失或损坏，会导致⽂件数据的丢失

**显式链接**：把⽤于链接⽂件各数据块的指针，显式地存放在内存的⼀张链接表中，该表在整个磁盘仅设置⼀张，每个表项中存放链接指针，指向下⼀个数据块号。内存中的这样⼀个表格称为⽂件分配表（File Allocation Table，FAT）

##### **索引方式**：

索引的实现是为每个⽂件创建⼀个「索引数据块」，⾥⾯存放的是指向⽂件数据块的指针列表

优点：⽂件的创建、增⼤、缩⼩很⽅便；不会有碎⽚的问题；⽀持顺序读写和随机读写；

**Unix ⽂件的实现⽅式**：多级索引

xv6时采取一级索引，在lab中添加了二级索引**

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-21-15-21-21-image.png)

### 空闲空间管理

空闲表法：空闲表法就是为所有空闲空间建⽴⼀张表，表内容包括空闲区的第⼀个块号和该空闲区的块个数，注意，这个⽅式是连续分配的。
空闲链表法：以使⽤「链表」的⽅式来管理空闲空间，每⼀个空闲块⾥有⼀个指针指向下⼀个空闲块。
位图法：位图是利⽤⼆进制的⼀位来表示磁盘中⼀个盘块的使⽤情况，磁盘上所有的盘块都有⼀个⼆进制位与之对应。

linux中，ext2文件系统采取块组的方式管理空闲空间。一个bitmap块最多能够管理128M内存，对于大文件来说不够用，

xv6中使用位图法来管理空闲磁盘空间，也就是bitmap块中的数据位，寻找空闲块时，通过遍历数据位来寻找。不过xv6的空闲内存时采用空闲链表来管理的。

### 目录存储

目录也是文件，也是通过inode+数据块的方式存储，只是目录中保存的信息是当前目录下文件的信息或者目录的信息。inode中，含有数据块的位置，数据块中保存哪些文件和目录信息。也就是entry。**普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。** 

最简单的保存格式就是**列表**，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。

linux中，entry保存的内容有：

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-21-16-10-11-image.png)

xv6系统中，是用entry的结构是inode的编号以及文件目录的名称。与linux差不多。

### 软链接和硬链接

硬链接就是不同的目录下存的是相同的inode，软连接就是不同目录下存放一个新的inode，这个inode指向的是对应的目录路径。

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-21-16-10-55-image.png)

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-21-16-11-52-image.png)

### lab：file system

1.增加xv6文件的最大大小，也就是一个inode能表示的最大大小。原来的文件是使用一级索引，为了扩大文件大小，添加一个二级索引。

2，添加软链接：根据路径名分配一个inode节点，然后将target添加到inode节点下的block中，也就是添加entry项。
