# 内存管理

主要内容：

## 内存分配：创建进程时如何分配，进程运行时如何分配

1. 进程运行时，调用malloc动态分配内存。

2. 应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。

若分配的内存很大，则内部是调用mmap（）在文件映射区中映射一块内存到页表中。

若分配的内存不大，则调用brk（）在堆区中分配一块内存映射到页表中，分配的是虚拟地址。

### 内存分配器是如何实现的？

内存分配器要完成一下几件事：

1. 把内存块通过某些方式组织起来：以某种数据结构记录内存的使用情况或者在内存块中存放内存区域的信息

2. 选择一块空闲块分配给进程：动态内存分配算法：首次适应，最佳适应，最坏适应，临近适应

3. 分配之后，剩余内存块如何处理：能合并的和并

## 内存回收：

### free（）时如何分配，

空闲内存块合并，什么时候合并

### 内存占满时如何交换

1. 内存占满时，先将进程交换到磁盘，首先内核线程再后台进行回收，如果依旧不够，则进行直接回收，若还是不够，则直接杀死一些进程。
   
   swap()机制

swappiness 的范围是 0-100：设置回收文件页还是匿名页的倾向

三个水位线

最小水位线（pages_min） 是触发直接回收的关键阈值 。当一个内存区域的可用页数下降到或低于这个水位线时，任何尝试从该区域分配内存的进程都会触发直接回收。这意味着系统已经处于严重的内存压力之下，必须立即采取行动来释放内存。  

低水位线（pages_low） 是唤醒kswapd后台回收守护进程的阈值 。当可用内存降至低水位线以下时，kswapd会开始异步扫描内存页，并尝试回收内存，直到可用内存达到高水位线。  

高水位线（pages_high） 是kswapd停止后台回收的目标阈值 。一旦可用内存达到或超过高水位线，kswapd就会进入睡眠状态，直到可用内存再次低于低水位线。  

## 虚拟内存

分段

分页

多级页表

段页式管理

虚拟内存分布：虚拟地址空间是怎么样的

虚拟内存：逻辑上扩展内存，隔离进程，提供安全性

操作系统为隔离性提供了硬件支持，一个是内核态和用户态，另外一个就是虚拟内存

虚拟内存：在同一个内存上，要想运行多个进程，那么需要将进程的地址隔离开来，使他们不会相互影响。**为使进程之间所使用的地址隔离开来，为每个进程都分配一套独立的虚拟地址，这样每个进程都有自己的地址空间，让进程看起来像是独享内存**。

由操作系统将虚拟地址映射到实际的物理地址上。所以操作系统要提供一种机制，将不同进程的虚拟地址映射到不同的物理地址上，实现每个进程使用自己的地址空间。

虚拟内存地址会被传到内存管理单元（MMU），MMU会将虚拟地址转换成物理地址。

## 映射方式：

内存分段（段表）

内存分页（页表）

段页式管理（段表+页表）

linux如何找到页表？

### 内存分段

将一个程序根据功能分成不同的段，比如：代码段，数据段，BSS段，栈去，堆区。

分段机制下的虚拟地址由两部分组成：**段选择因子+段内偏移量**

段选择⼦就保存在**段寄存器**⾥⾯。段选择⼦⾥⾯最重要的是**段号**，⽤**作段表的索引，从而在段表中找到段内描述符。** 段表⾥⾯保存的是这个段的基地址、段的界限和特权等级等。
虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-22-19-53-49-image.png)

**好处是段内都是连续的内存空间，访问速度比较快。**

### 内存分段的缺点

1. 第⼀个就是内存碎⽚的问题。

     外部碎片：程序分段时，每一个段可能比较大，占用较多的内存，然后程序在内存中不采取连续存放的方式，而是非连续存放的方式，所以段与段之间会存在一些空闲内存片段，这些片段可能会很小，从而无法存放新的段，导致这些空闲内存一直不被使用，从而形成了外部内存碎片。（**间隙之间的空闲内存一直不被使用**）

    内部碎片：程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使⽤，这也会导致内存的浪费（**存放了程序的内存空间中有些程序不常用从而导致一直不被访问**）

       解决外部碎片的办法：内存交换或者挪动代码段，将其紧密存放。

1. 第⼆个就是内存交换的效率低的问题。

       因为硬盘的访问速度要⽐内存慢太多了，每⼀次内存交换，我们都需要把⼀⼤段连续的内存数据写到硬盘上。

        内存交换以段位单位操作，但是有的段可能很大，如果内存交换的时候，交换的是⼀个占内存空间很⼤的程序，这样整个机器都会显得卡顿。

### 内存分页

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。在 Linux 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射。

页表是存储在内存里的，**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。（lazy allocation）

在分⻚机制下，虚拟地址分为两部分，⻚号和⻚内偏移。⻚号作为⻚表的索引，⻚表包含物理⻚每⻚所在物理内存的基地址，这个基地址与⻚内偏移的组合就形成了物理内存地址，⻅下图。

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-22-20-49-45-image.png)

对于⼀个内存地址转换，其实就是这样三个步骤：
把虚拟内存地址，切分成⻚号和偏移量；
根据⻚号，从⻚表⾥⾯，查询对应的物理⻚号；
直接拿物理⻚号，加上前⾯的偏移量，就得到了物理内存地址

### 内存分页的缺点：

 会有内部内存碎片的现象

### 多级页表

采用单级页表，所有的虚拟内存都需要映射到这一个页表中，页表中要包含很多pte，从而导致页表本身就很庞大，所以采取多级页表的方式。

如果将所有虚拟地址空间都映射到页表中，那么采取多级页表的方式反而会比单极页表占用更多的空间。因为所有的末级页表映射的空间之和就是整个虚拟地址空间，而采取多级之后，就还会有一级，二级等页表的内容。

但是，虚拟地址间往往比较大，所以多级页表只需要映射用到了的地址空间。所以就减少了页表的大小。当访问到没有映射的空间是，在改变页表即可。

查找页表由硬件实现。一般系统中有一个页表寄存器。

页表存放在内存中，PCB中会保存页表地址的信息，因为页表寄存器中保存的只是当前正在运行进程的页表，所以各自的进程页需要知道自己的页表在上面地方。xv6系统中是保存在proc结构体中。

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-22-20-59-27-image.png)

### 页表缓存（TLB）：

 存放的是虚拟地址和物理地址的映射，如果在TLB中找到了虚拟地址，则直接返回物理地址，不去查找页表。

### Linux内存管理机制

linux本意是采取分页管理，但是由于处理器的原因，也就是引荐设计的原因，必然会带有分段机制。linux中将所有的段基址都设置为0，这样所有的段就都重合，都只用同样大小的虚拟地址空间。

至于不同的段在同一虚拟地址空间中是通过链接地址区分的，也就是，不同的段内的偏移地址，不都是从0开始的，而是使用链接脚本的地址规定的范围。

通过这样的操作，linux系统使分段机制不起什么作用。

**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是⼀样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应⽤程序代码，所⾯对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被⽤于访问控制和内存保护。**

### Linux内存分布

32位：代码段，数据段，堆区，文件映射区，栈区，内核区。经典结构中，栈区和文件映射区相对生长，堆区向上生长。

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-23-21-17-42-image.png)

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-04-23-21-14-31-image.png)
