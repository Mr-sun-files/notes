系统调用内部机制

用户态下的进程使用内核服务，使用系统调用接口，这些接口有glibc库提供。

open/read/write/close

#### 系统调用接口如何实现？

系统调用触发一个异常，进入到内核中处理异常，内核要分辨处理异常，然后返回用户空间

如何触发异常？

执行汇编指令swi/svc就触发异常

设置触发异常的原因：

分辨，处理异常：如何传递原因，也就是如何调用处理函数？

将异常的原因存储在寄存器中，比如R7,R8

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-05-08-19-30-05-image.png)

64位处理器

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-05-08-19-30-13-image.png)

然后，调用到不同的函数

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-05-08-19-31-28-image.png)

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-05-08-19-36-40-image.png)

这个宏会定义出sys_open()函数

文件描述符fd如何与具体文件挂钩

不同进程的文件打开表不同，每个进程有自己的打开文件表，

#### 内核中的open函数做了什么事情？

1，获得未使用的文件句柄fd，

2，打开具体的文件，得到file结构体

3，将file记录到进程中，记录到files结构体中fdtable结构体中的fd数组中

![](E:\课程及内核源码\01_all_series_quickstart\09_u-boot完全分析与移植\doc_pic\pic\2025-05-08-19-51-36-image.png)

在同一个进程中调用open打开同一个文件时，文件打开表中是用两个文件描述符表示它们，也就是，对应不同的file结构体，分别读写时，它们内部的文件偏移值也是用的是各自的偏移值，就相当于，操作的是两个文件。

若要用两个文件句柄指向同一个文件，要用dup系统调用

lseek系统调用
